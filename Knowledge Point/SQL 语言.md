# SQL
## 关系代数
* 设有两个关系模式相同的关系R和关系S
* 关系的特点：不允许存在重复值。
1. 并运算
	* R∪S表示关系R和关系S的元组集合。
2. 差运算
	* R-S表示从关系R中去除属性关系S的那部分，剩下的为差结果。
3. 笛卡儿积运算
	* R×S表示用关系R的每一条元组与关系S中所有元组分别联接。
	* 特点：
		1. 关系R有m个基数，关系S有n个基数，则关系R×S后有m*n个基数。
		2. 关系R有元素m个，关系R有元数n，则关系R×S后有元数m+n个。
4. 投影
	* 从一个关系中抽取若干个属性组成一个新的关系。
	* 表示π属性1，属性2，...(关系)。
5. 选择
	* 从一个关系中水平方向抽出满足条件的元组。
	* 表示：δ条件（关系）
	* 操作：
		1. 扫描关系中每一个元组
		2. 若满足条件，抽取出来
		3. 若不满足条件，则扫描下一条，直到表尾结束。

## MySql约束
1. primary key 主键 
	1. 不为null，不重复
	2. create table tablename(filed type primary key);
2. 自增
	1. create table name (filed type auto_imcrement);
3. 带条件创建
	1. create database if not exits name;
	2. create table if not exists tablename;
	3. drop database if exists name;
4. 插入
	1. insert into tablename(filed1,filed2,...) values(value1,value2,...);
	2. 
4. 查询
	1. 运算符：`> >= < <= = <>`。
	2. 包含运算：`in    not in`。
	3. 多条件：将单条件用`and or`连接。
	4. `between ... and ...`表示介于某个区间的值。
	5. 包含运算。`where filed in (value1,value2,...)`，该字段包含in后任一一个值即可。
	6. 不包含运算。`where filed not in (value1,value2,...)`。
	7. 关键字 `distinct`，消除重复。
	8. 多表查询
		1. `from tablename1,tablename2`，同名字段必须加表名限制。
	9. 嵌套查询（多表查询）
		1. 嵌套查询是一次两个查询
		2. 内层查询的结果是外层查询的条件
		3. 查询顺序
			1. 先进行内层查询，将查询结果传至外层。
			2. 外层根据内层查询的结果进行查询。
		4. 结构
			````SQL
			select filed from tablename where 字段 运算符
				(select filed from tablename where 字段 运算符）；
			````
			* 外层需要什么值，内层就需要查什么值。
			* 要查的字段在一个表，而条件在另一个表。
	5. 分组计算查询
		1. 计算查询
			* 对select语句中查询的结果进行计算。计算形式：计算函数（filedname）。
			* 聚焦函数（统计）
				1. count() 计数
				2. max()
				3. min()
				4. avg()
				5. sum()
				* 若字段是主键，则可以使用`*`代替。
		2. 分组计算查询
			1. 分组字段：属性上将一个上下相同的值归为一组。
			2. 计算长度：在每个分组上进行计算。
			3. 分组条件：分组字段上用来参与查询计算的分组。若无分组条件，则所有分组将参与。
			4. 表示：
				````
				select ... from ... where ...
					group by 分组字段
						having 分组条件；
				````
	6. 量词查询
		1. 量词： `some(any)` 满足任何一个；`all` 满足所有。
		2. 原因：>= any 等价于 >= 最小值；>= all 等价于 >=最大值；<=any 等价于 <= 最大值；<= all 等价于 <=最小值。
	7. 空值查询
		1. 空值：null。空值是一个值，不确定。
	8. 联合查询
		````
		select ... from ... where ...
		union
		select ... from ... where ...
		````
		* 要求两个要查询的SQL语句的select字段必须相同。
	9. 排序
		1. 对最终的查询结果进行排序，对最后select短语中结果进行排序。
		2. 对于嵌套，排序只能放在外层。
		3. order by filed [desc/asc] 降/升序排列，可组合多个字段
		4. 默认升序
	10. 谓词查询
		1. exists 和 not exists。
		2. 过程：外层逐条扫描所有元组，每扫描一条元组，将该元组的相关属性值传递到内层，内层按传递的值进行查询，并向外层返回是否存在查询结果，外层按exists，not exists进行判断。
	11. 模糊查询
		1. ````%````,0个或多个字符
		2. ````_````,一个字符，作字符内容使用时，应使用转义符
	12. 分页查询
		1. limit 偏移量，个数
## 视图
1. 视图是一个虚拟表，不存储二维表，只存储查询。通过视图查看表时，只能看到满足条件的元组。
1. 视图的工作机制:当调用视图的时候，才会执行视图中的sql，进行取数据操作。视图的内容没有存储，而是在视图被引用的时候才派生出数据。这样不会占用空间，由于是即时引用，视图的内容总是与真实表的内容是一致的。
2. 视图这样设计有什么好处？节省空间，内容是总是一致的话，那么我们不需要维护视图的内容，维护好真实表的内容，就可以保证视图的完整性了。
3. 安全性。一般是这样做的:创建一个视图，定义好该视图所操作的数据。之后将用户权限与视图绑定。这样的方式是使用到了一个特性：grant语句可以针对视图进行授予权限。
4. .复杂的查询需求。可以进行问题分解，然后将创建多个视图获取数据。将视图联合起来就能得到需要的结果了。
5. 有灵活性的功能需求后，需要改动表的结构而导致工作量比较大。那么可以使用虚拟表的形式达到少修改的效果。
## 索引
## 连接
1. 内连接
	* 仅选出两张表中互相匹配的记录。内连接是两张表中都必须有连接字段的对应值记录，数据才能被检索出来。
	* 内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行。
	* inner join
2. 左连接
	* 只要左边表中有记录，数据就能被检索出来，而右边有的记录必须在左边表中有的记录才能被检索出来。
	* 左向外连接的结果集包括左表的所有行，而不仅仅是连接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。
	* left join
3. 右连接
	* 只要右边表中有记录，数据就能被检索出来；
	* 右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 
	* right join
4. 全连接
	* 会返回两个表中所有的记录。
	* 完整外部连接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。
	* full join
5. 交叉连接
	* 交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。
